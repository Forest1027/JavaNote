# QC for SE
## 集合
1. 体系是怎样的
	1. 分为Collection接口和Map接口
		1. Collection接口-单列集合。所有实现类都可以迭代，并且只能存储引用类型元素
			1. List接口。存储元素的特点：有序可重复，有索引
				1. ArrayList：底层是数组，因此查询快，增删慢
				2. LinkedList：底层是双向链表，因此增删快，查询慢
				3. Vector：底层是数组，后来被ArrayList替代。
					1. **两者差异**：
					2. Vector是线程安全的，同步，因此效率低
					3. ArrayList线程不安全，不同步，效率高
					4. 另外，ArrayList改善了方法的名字，名字更短
			2. Set接口。存储元素的特点：无序不可重复
				1. HashSet
				2. SortedSet接口：无序不重复，但是存储进去的元素可按大小自动排序
					1. TreeSet
		2. Map接口-双列集合。以键值对的形式存储元素，键无序不可重复
			1. HashMap
			2. Hashtable：线程安全，效率低
				1. 子类Properties，以键值对(只能是字符串)的形式存储
			3. SortedMap接口：无序不重复，但可按元素大小自动排序，键相当于SortedSet集合
				1. TreeMap
2. 各个常用的集合都是长什么样的呢？
3. 常见数据结构
	1. 数组
		1. 查找元素快：通过索引，可以快速访问指定位置的元素
		2. 增删元素慢 ,每次添加元素需要移动大量元素或者创建新的数组
		3. 数组结构增删数据的方式：创建新的数组，长度为原长度上加减，然后遍历元数组，遇到特定函数，在其后插入新元素。
	2. 链表
		1. 多个节点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。
		2. 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素
		3. 增删元素快：
			1. 增加元素：只需要修改连接下个元素的地址即可。
			2. 删除元素：只需要修改连接下个元素的地址即可。
	3. 栈&队列
		1. 栈：先进后出
		2. 队列：先进先出
4. 遍历的方法
	1. 单列集合
		1. 普通for循环(用到索引)[只适合List集合]
		2. Collection接口中的toArray()方法，将集合转为Object类型的数组[List和Set均可]
		3. Iterator迭代器[均可]
		4. ListIterator迭代器[只适合List集合]
		5. 增强for[List和Set均可]
	2. 双列集合
		1. 利用keySet()方法遍历
			1. 召集所有丈夫去找妻子
		2. 利用entrySet()方法遍历
			1. 获取所有结婚证
5. HashSet的唯一性原理
	1. 新添加到HashSet集合的元素都会与集合中已有的元素一一比较
	2. 首先，比较Hash值。
		1. 如果不同-->存入集合
		2. 相同-->调用equals比较
			1. equals的结果为true-->与已有元素的属性值相同，不存入集合
			2. equals的结果为false-->与已有元素的属性值不同，存入集合

# 面向对象
* 继承
	* 特点
		* 类只支持单继承，不允许多继承
		* 多个类可以继承一个父类
		* 多层继承是可以的
	* 继承中成员变量的特点
		* 子类只能继承父类非私有成员（变量及方法）
		* 就近原则
			* 有局部变量就用局部变量
			* 没局部变量，子类有就用子类的
			* 再没子类的，就用父类的
			* 都没有，报错
	* 继承中成员方法的特点
		* 子类没有该方法的，调用父类的
		* 子类重写了父类方法，调用子类的

> **方法的重写与方法的重载**
> 方法的重写：在子父类当中，子类的方法和父类的完全一样，子类重写了父类的方法（覆盖），当子类重写了父类的方法之后，使用子类对象调用的就是子类的方法
> 方法的重载：在一个类中，有多个重名的方法，但是其参数不一样（参数的个数，参数的类型，参数的顺序），和返回值无关

> **方法重写的应用场景和注意事项**
> 应用场景：父类方法无法满足需求
> 注意事项：1.不可以重写父类私有成员方法；2.权限必须大于等于父类方法的权限

* 继承中构造方法的执行顺序
	* 先执行父类无参构造
	* 再执行子类构造
* 继承的优缺点
	* 优点
		* 提高了代码的复用性
		* 提高了代码的可维护性
	* 缺点：
		* 类的耦合性增强了
		* 开发的原则：高内聚低耦合
		
> 内聚：就是自己完成某件事情的能力
> 耦合：类与类的关系

* 多态
	* 前提：
		* 子父类的继承关系
		* 方法的重写
		* 父类引用指向子类对象
	* 多态的成员特点:
		* 成员变量  编译时看的是左边，运行时看的左边
		* 成员方法  编译时看的是左边，运行时看右边
		* 静态方法  编译时看的是左边，运行时看的也是左边
	* 优缺点：
		* 优点：可以提高可维护性（多态前提所保证的），提高代码的可扩展性
		* 缺点：无法直接访问子类特有的成员

* 接口
	* 接口是一个比抽象类还抽象的类，接口里所有的方法全是抽象方法，接口和类的关系是实现，implements
	* 接口成员的特点：
		*　只能有抽象方法
		*　只能有常量
		*　默认使用public&abstract修饰方法
		*　只能使用public&abstract修饰方法
		*　默认使用public static final来修饰成员变量
	*　接口优点
		*　类与接口的关系，实现关系，而且是多实现，java中的继承是单一继承，一个类只能有一个父类，打破了继承的局限性。
		*　对外提供规则（USB接口）
		*　降低了程序的耦合性（可以实现模块化开发，定义好规则，每个人实现自己的模块，提高了开发的效率）

＞注意：接口是没有构造方法的

# 关键字篇
* 静态static
	* 特点
		* 被所有的对象所共享
		* 被static修饰的成员可以并且建议通过类名直接访问
		* 静态的加载优先于对象,随着类的加载而加载
	* 注意事项
		* 静态成员只能直接访问静态成员
		* 非静态成员既可以访问非静态成员也可以访问静态成员
		* 静态中没有this这个对象
	* 优点：
		* 对对象的共享数据提供单独空间的存储，**节省空间**
		* 可以直接被类名调用,**不用在堆内存创建对象**
		* 通过类名直接访问,相对创建对象访问成员**方便**
	* 缺点：
		* 访问出现局限性。（静态虽好，但只能访问静态）
	* 静态代码块：
		* 它优先于主方法执行、优先于构造代码块执行，当以任意形式第一次使用到该类时执行。
		* 该类不管创建多少对象，静态代码块只执行一次。
		* 可用于给静态变量赋值，用来给类进行初始化。

> 静态方法：
>	可以调用静态的成员变量
>	可以调用静态的成员方法
> 	不可以调用非静态成员变量
> 	不可以调用非静态成员方法
> 	静态方法只能调用静态的成员
> 非静态方法：
> 	可以调用静态的成员变量
> 	可以调用静态的成员方法
> 	可以调用非静态的成员变量
> 	可以调用非静态的成员方法

> 类变量(静态变量)与实例变量(非静态变量)

* final
	* 可以用于修饰类、成员方法和成员变量
	* final所修饰的类：不能被继承，不能有子类
	* final所修饰的方法:不能被重写
	* final所修饰的变量：是不可以修改的，是常量

* abstract
	* 用于修饰方法和类
	* 抽象方法：不同类的方法是相似，但是具体内容又不太一样，所以我们只能抽取他的声明，没有具体的方法体，没有具体方法体的方法就是抽象方法
	* 抽象类：有抽象方法的类必须是抽象类
	* 特点：
		* **抽象方法只能在抽象类里面**
		* 抽象类中可以有非抽象的方法
		* 抽象类和抽象方法必须被abstract修饰
		* 抽象类不能创建对象（不能实例化）
		* 抽象类和类的关系也是继承
	* 抽象类成员的特点
		* 成员变量
			* 可以有成员变量
			* 可以有常量
		* 成员方法
			* 可以有抽象方法
			* 可以有非抽象方法
		* 构造方法
			* 可以有构造方法的，需要对抽象类的成员变量进行初始化

>注意：一个类继承了抽象类需要重写他所有的抽象方法,否则这个类就得是抽象类
>
>abstract 不能和哪些关键字共存
>* private
>* final
>* static
>
>抽象类可以不定义抽象方法，意义在于不让该类创建对象

# 多线程
* 进程与线程
	* 进程
		* 当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。
	* 线程
		* 线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。
	* 区别：
		* 线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务
		* 不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。
	* 线程和进程一样分为五个阶段
		* 创建 创建线程/进程对象
		* 就绪 具备了执行条件，没有具备执行权力
		* 运行 具备了执行条件以及执行权力
		* 阻塞 
		* 终止 成为垃圾
* [死锁产生原因及解决办法](http://blog.csdn.net/ls5718/article/details/51896159)

# IO流

# 反向代理
# 动态代理
# 反射
# ssh、ssm